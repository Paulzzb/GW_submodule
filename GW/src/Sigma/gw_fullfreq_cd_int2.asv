function sint = gw_fullfreq_cd_int2(GWinfo, options)
% This file will be final version for the full-frequency GW calculation.
% Generally speaking, user should not directly call this function, instead
% call this indirectly by calling through gwCalculation->gw_fullfreq_cd.

% Description
%     Calculate the self-energies using contour integral idea within the GW method.
%     This code only computes the integral on the imaginary axis,  

% Parameters
%   Input:
%     GWinfo: class @GWinfo, contains ground-state information.
%     options: class @GWOptions, contains necessary parameters for the calculation.
%   Output:
%     sint: the integral on imaginary axis, size nbandener*1.

% Structure 
%   The code is organized as followed:
%     0. Initialize inputs.
%     1. Generate the qudrature weights and the quadrature node on the nary axis.
%        For each frequencies omega
%     2    Calculate W(omega)
%          For each band to calculate n
%     3.     Calculate <nn'|W(omega)|nn'> for all n'. 
%     4.     Multiply the coefficient and add the result to sint  
%          end 
%        end 

% flag2 is for method (numerically equal, suggest to use flag2 = true.)
flag2 = 1;
% flag2 = 1;
ii = sqrt(-1);
ind_bgw2ks = options.Groundstate.ind_bgw2ks;

startintgral = tic;

% 0. Initialize
% Initialize constant from options.Constant
nameConstants = fieldnames(options.Constant);
for i = 1:numel(nameConstants)
  fieldname = nameConstants{i};
  value = options.Constant.(fieldname);    
  if ~isempty(value)
    strEval = sprintf('%s = %.16f;', fieldname, value);
    eval(strEval);
  end
end
mi = sqrt(-1);
bandtocal = nv-nv_ener+1:nv+nc_ener;
n_ener = length(bandtocal);

% Initialize other values
GWinfo.Z     = GWinfo.Z * sqrt(vol);
ev    = GWinfo.ev;
Dcoul = spdiags(GWinfo.coulG(:,4), 0, ng, ng);
aqsFlag = ~isempty(GWinfo.aqs);
Dcoul(1, 1) = GWinfo.coulG0;
% Energies use unit 'ev' in this code.
% Since both KSSOLV_dft and frequency generating part use Ry as unit
% Change unit first.
ev = ev * ry2ev;
Dcoul = Dcoul * ry2ev;

% 1. Generate frequency sequences in imaginary axis.
startFrequencyGen = tic;
[grid_real, ~, grid_imag, coeff_imag_func] = freqgen(GWinfo, options);
nfreq_real = length(grid_real);
nfreq_imag = length(grid_imag);
eta = 0;
% eta = 1e-4;
timeFrequencyGen = toc(startFrequencyGen);
fprintf('Time for Generating Frequencies = %.3s.\n', timeFrequencyGen);



load nm_W_nm.mat;

sint = zeros(n_ener, 1);
for ifreq = 1:nfreq_imag
  omega = grid_imag(ifreq);
  coeff_func = coeff_imag_func{ifreq};
  nm_W_nm_table = fourcenterintegral(GWinfo, options, 1.0, omega, ...
            [nv-nv_ener+1, nv+nc_ener], [nv-nv_ener+1, nv+nc_ener]);
  norm(nm_Womega_nm(:,:,ifreq)-nm_W_nm_table)
  for ibandener = nv-nv_ener+1:nv+nc_ener
    ibe = ibandener-nv+nv_ener;
    for ibandoper = nv-nv_oper+1:nv+nc_oper
      ibo = ibandoper-nv+nv_oper;
      x = (ev(ibandener) - ev(ibandoper)) + TOL_SMALL;
      % if abs(x) < TOL_SMALL
      %   coeff = coeff_func(TOL_SMALL);
      % else
        coeff = coeff_func(x);
      % end
      nm_W_nm = nm_W_nm_table(ibe, ibo);
      sint(ibe) = sint(ibe) + coeff*nm_W_nm;
    end
  end
end


% sint = sint / pi * ry2ev;
sint = sint / pi;
[real(sint), imag(sint)];

timeintegral = toc(startintgral);
fprintf("Time to integral on Imaginary axis = %.2d.\n", timeintegral);
end
